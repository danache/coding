Q1.void*大小？
void* 可以看做一个integeral type.
sizeof(void*)是取决于这个整形量有多少个字节而不是取决于其指向了啥决定的。
void*有多大看编译器目标平台类型。x86通常4 bytes. x64通常8bytes
2.
请问下面的程序一共输出多少个“-”？为什么？
①int main(void) {
   int i;
   for (i=0; i<2; i++) {
      fork();
      printf("-\n");
   }
   return 0;
}
②
int main(void) {
   int i;
   for (i=0; i<2; i++) {
      fork();
      printf("-");
   }
   return 0;
}
答案：①为6个，②为8个。
首先fork()是可以复制父进程的缓存，变量值等信息.
①
i＝0时，父进程A产生一个子进程A1，此时输出两行“－”；
i＝1时，fork使父进程A产生子进程A2，A1产生子进程A3，此时A－A3共产生4行“－”（因为现在A，A1的输出行缓冲均为空）；
总数为6：2（A）＋2（A1）＋1（A2）＋1（A3）＝6； 
若还能循环一次，则3（A） + 3(A1) + 2(A2) + 2 (A3) + 4 = 14.

②I=0时，父进程A产生一个子进程A1，此时不输出！！因为没有\n清除缓冲区，相当于子进程也复制了父进程的缓冲区，即里面有一个'-'
假设父A0,子A1，现在缓冲区各有一个'-'。
I =1时，A1产生A3，A2产生A4，各有两个'A'.共有8个
若还能循环一次,应该为8 * 3 = 24个。
3.
动态联编 只能通过指针或引用标识对象来操作虚函数 ;如果采用一般的标识对象来操作虚函数,将采用静态联编的方式调用虚函数
4.
 以下代码输出什么____.  

main()
{
   int a[5]={1,2,3,4,5};
   int *p=(int *)(&a+1);
   printf("%d",*(p-1));
}

答案：5
第二句话将p赋值为一个指针。&a + 1意思是a这个指针地址的下一位，即指向下一个数组的指针（这个数组未定义），但是p-1指向的就是a中的最后一位，即5.
5.